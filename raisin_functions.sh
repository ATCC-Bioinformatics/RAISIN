#!/bin/bash
# set -e
shopt -s expand_aliases
source /home/shared/bash.bashrc

logger(){
    #written for general cleanliness in other functions
    phrase=$1
    action_status=$2
    echo "--------------------------------------------------------------------------------------------------------------------------------------------------------------------" >&2
    if [ $action_status = "Success" ]; then
        echo "$(date) $phrase was successful!"| tee -a "$log_path" >&2
    elif [ $action_status == "Start" ]; then
        echo "$(date) Starting $phrase "| tee -a "$log_path" >&2
    elif [ $action_status == "Done" ]; then
        echo "$(date) Y'all've already done this. Passing $phrase" | tee -a "$log_path" >&2
    elif [ $action_status == "Fail" ]; then
        echo "$(date) $phrase failed."| tee -a "$log_path" >&2
    else
        echo "$(date) You forgot a status - this message should never be seen"| tee -a "$log_path" >&2
    fi
    echo "--------------------------------------------------------------------------------------------------------------------------------------------------------------------" >&2
}
export -f logger

map_reads() {
    local r1_path=$1
    local r2_path=$2
    local reference_path=$3
    local output_dir_path=$4
    local threads=$5
    local bam_path=$6

    # variables for initial mapping and vcf used for bqsr
    local bam_pre_bqsr="$output_dir_path"/pre-bqsr.bam
    local bamqc_path="$output_dir_path"/bamqc
    local vcf_pre_bqsr="$output_dir_path"/pre-bqsr.vcf

    # variables for data generated by bqsr
    local cal_tbl_path="$output_dir_path"/bqsr_recalibration.tbl
    local cvtplot_path="$output_dir_path"/recalibration_quality.pdf # formerly, analyze_covariates

    logger "gatk." "Start"| tee -a "$log_path" >&2
    
    {
    # generate an initial bam file, sort it, assign a single read group, do qc
    # gatk requires explicit read groups for downstream steps
    #if the dict file exists, keep going. If it does not, run gatk CreateSequenceDictionary
    [ -f $(basename $reference_path .fasta).dict ] || gatk CreateSequenceDictionary -R "$reference_path"
    
    logger "GATK" "Success" | tee -a $log_path >&2
    logger "bwa mem" "Start"| tee -a "$log_path" >&2
    
    }

    { bwa index "$reference_path" &&
    bwa mem \
        -t $threads \
        "$reference_path" \
        "$r1_path" \
        "$r2_path" > $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).sam 2>&2
    lofreq viterbi -f "$reference_path" $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).sam > $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).lofreq.viterbi.bam 2>&2
    samtools sort -@ $threads $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).lofreq.viterbi.bam > $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).sorted.bam 2>&2
    # these read group metadata are really just default placeholders
    picard AddOrReplaceReadGroups \
        -I $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).sorted.bam \
        -O "$bam_pre_bqsr" \
        -RGLB 1 \
        -RGPL illumina \
        -RGPU unit1 \
        -RGSM sample 2>&2
    }

    if [ -f $bam_pre_bqsr ]
    then
        logger "Mapping, realignment, sorting by leftmost coordinates, demultiplexing and artifact manipulation" "Success" | tee -a "$log_path" >&2
    else
        logger "bwa index, bwa mem, lofreq viterbi, samtools sort, or picard.jar AddOrReplaceReadGroups" "Fail"| tee -a "$log_path" >&2
        exit
    fi
    logger "initial variant calling + BQSR" "Start"| tee -a "$log_path" >&2

    { # bcftools without ploidy option for initial variant call set for BQSR
    bcftools mpileup \
        -f "$reference_path" \
        -d 8000 \
        --threads "$threads" \
        -Ou \
        "$bam_pre_bqsr" > $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).mpileup 2>&2
    bcftools call --threads "$threads" -M -mv -Ou $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).mpileup > $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).bcf.call 2>&2
    bcftools filter --threads "$threads" -Oz -i 'QUAL>=30' -o "$vcf_pre_bqsr".gz $output_dir_path/debug.reads_to_$(basename $reference_path .fasta).bcf.call 2>&2 &&
    gatk IndexFeatureFile -I "$vcf_pre_bqsr".gz --verbosity DEBUG 2>&2 &&
    # GATK run for BQSR
    gatk BaseRecalibrator \
        -I "$bam_pre_bqsr" \
        -R "$reference_path" \
        --known-sites "$vcf_pre_bqsr".gz \
        --verbosity DEBUG \
        -O "$cal_tbl_path" 2>&2 &&
    gatk ApplyBQSR \
        -R "$reference_path" \
        -I "$bam_pre_bqsr" \
        --bqsr-recal-file "$cal_tbl_path" \
        --verbosity DEBUG \
        -O "$bam_path" 2>&2 &&
    gatk AnalyzeCovariates \
        -bqsr "$cal_tbl_path" \
        --verbosity DEBUG \
        -plots "$cvtplot_path" 2>&2 &&
    qualimap bamqc \
        -nt "$threads" \
        -bam "$bam_path" \
        -outdir "$bamqc_path" \
        -outformat PDF:HTML 2>&2
    }
    if [ -f "$bamqc_path"/report.pdf ]
    then
        logger "Initial variant calling, base quality score recalibration (BQSR), and statistical analysis of bam alignment" "Success"| tee -a "$log_path" >&2
    else
        logger "initial variant calling (bcftools), BQSR (gatk), or bam quality control (qualimap bamqc)" "Fail"| tee -a "$log_path" >&2
        exit
    fi
}

call_variants() {
    local reference_path=$1
    local bam_path=$2
    local vcf_path=$3
    local threads=$4
    local min_freq=$5
    local min_cov=$6

    local indelqual_bam_path="${bam_path::-4}"_indelqual.bam
    local indelqual_alnqual_bam_path="${bam_path::-4}"_indelqual_alnqual.bam
    local indelcall_vcf_path="${vcf_path::-4}"_indelqual.vcf

    if [[ $vcf_path == *"reads_to_reference"* ]] || [[ $vcf_path == *"reads_to_assembly"* ]]
    then
        logger "Generating variant calls with LoFreq using $vcf_path" "Start"| tee -a "$log_path" >&2
        echo -e "$reference_path/t$bam_path/t$vcf_path" | tee -a "$log_path" >&2
        
    {

    lofreq indelqual --dindel -f $reference_path $bam_path > $indelqual_bam_path 2>&2
    lofreq alnqual -b $indelqual_bam_path $reference_path > $indelqual_alnqual_bam_path 2>&2
    samtools index $indelqual_alnqual_bam_path 2>&2
    lofreq call-parallel --pp-threads $threads --call-indels -f $reference_path $indelqual_alnqual_bam_path -o $indelcall_vcf_path 2>&2
    # lofreq filter -i $indelcall_vcf_path -v 10 -a 0.05 > $vcf_path 2>&2
    lofreq filter -i $indelcall_vcf_path -v "$min_cov" -a "$min_freq" > $vcf_path 2>&2
    if [ -f "$vcf_path" ]
    then
        logger "LoFreq variant calling" "Success"| tee -a "$log_path" >&2
    else
        logger "variant calling with lofreq" "Fail"| tee -a "$log_path" >&2
        exit
    fi
    }
    else
        {
        lofreq indelqual --dindel -f $reference_path $bam_path > $indelqual_bam_path 2>&2
        lofreq alnqual -b $indelqual_bam_path $reference_path > $indelqual_alnqual_bam_path 2>&2
        samtools index $indelqual_alnqual_bam_path 2>&2
        lofreq call-parallel --pp-threads $threads --no-default-filter -C 1 -f $reference_path $indelqual_alnqual_bam_path -o $vcf_path 2>&2
        #lofreq filter -i $indelcall_vcf_path -v 1 > $vcf_path
        if [ -f "$vcf_path" ]
        then
            logger "LoFreq variant calling successful" "Success"| tee -a "$log_path" >&2
        else
            logger "variant calling with lofreq" "Fail"| tee -a "$log_path" >&2
            exit
        fi
        }
    fi
}

call_consensus() {
    local bam_path=$1
    local vcf_path=$2
    local reference_path=$3
    local output_dir_path=$4
    local consensus_path=$5
    local threads=$6
    local min_cov=$7

    local bed_path=$output_dir_path/low-coverage-regions.bed
    local bed_path_temp=$output_dir_path/low-coverage-regions_temp.bed

    if [ -f "$consensus_path" ]; then
    logger "Consensus generation:" "Done"| tee -a "$log_path" >&2
    else
    logger "to calculate low coverage regions using bedtools" "Start"| tee -a "$log_path" >&2
    bedtools genomecov -ibam "$bam_path" -bga |
        awk -v min="$min_cov" -F $'\t' '$4 < min' > "$bed_path_temp" 2>&2

    if [ $(stat -c %s "$bed_path_temp") -gt 0 ]
    then
        bedtools merge -o mean -c 4 -i "$bed_path_temp" > "$bed_path" 2>&2
        logger "Generation of $bed_path" "Start"| tee -a "$log_path" >&2
    else
        logger "bedtools genomecov and merge" "Fail"| tee -a "$log_path" >&2
    fi
    logger "generation of lofreq consensus sequence" "Start"| tee -a $log_path >&2

    if [ $(stat -c %s "$bed_path") > 0 ]
    then
        python $(dirname $0)/consensus.py -r "$reference_path" -v "$vcf_path" -b "$bed_path" -o "$consensus_path" 2>&2
    else
        # Create empty bed file
        touch "$bed_path"
        python $(dirname $0)/consensus.py -r "$reference_path" -v "$vcf_path" -b "$bed_path" -o "$consensus_path" 2>&2
    fi
        # report success
        if [ -f "$consensus_path" ]
        then
        logger "Generation of $consensus_path" "Success"| tee -a "$log_path" >&2
        else
        logger "Consensus creation" "Fail"| tee -a "$log_path" >&2
        exit
        fi
    fi

}

read_counter(){
    logger "Read counter for $1" "Start"
    reads=$1
    if ( file "$reads" | grep -q compressed ) ; then
        count=$(echo $(zcat $reads | wc -l) /4 | bc)
        Ns=$(zcat $reads | awk '(NR%4 == 2)'|grep -o N | wc -l) #only check within the nucleotide line
        mean_len=$(zcat $reads | awk '{if(NR%4 == 2) {count++; bases += length} } END {print bases/count}')
    else
        echo counting
        count=$(echo $(wc -l $reads|cut -d\  -f1)/4 | bc)
        echo ontoNs
        Ns=$(awk '(NR%4 == 2)' $reads | grep -o N | wc -l)
        echo ontoLength
        mean_len=$(awk '{if(NR%4 == 2) {count++; bases += length} } END {print bases/count}' $reads)
    fi #compressed? Gather stats!

    #if there are no Ns, it will return empty
    if [ -z $Ns ]
    then
        Ns=0
    fi

    bases=$(echo "$count*$mean_len" | bc|cut -d\. -f1)
    if [[ $count < 1000 ]]
    then
        logger "reads too low to continue" "Fail"
        exit
    fi
    Nextra=$(echo ${Ns}*100 | bc)
    if [ $(echo "$Nextra/$bases" | bc) -gt 25 ] #25 is arbitrary starting number to represent 25% because bc doesn't do decimals
    then
        logger "too many Ns!" " Fail"
        exit
    fi

}

trim_filt(){
    output_dir=$1
    threads=$2
    fwd=$3
    rev=$4

    mkdir -p $output_dir/pre_QC
    if [ -f "$output_dir"/$(basename $fwd .fastq.gz).filtered.fastq.gz ]
    then
        logger "Read trimming and filtering" "Done" | tee -a "$log_path" >&2
    else
        logger "Read trimming and filtering with fastp." "Start" | tee -a "$log_path" >&2
        read_counter $fwd
        read_counter $rev
        #often times, fastp will get stuck on a sample. We're giving it a 10 minute opportunity to succeed, after which it will run repair.sh and try again
        if [ $(readlink -- "$fwd") ]
        then
            if ( file $(readlink -- "$fwd") | grep -q compressed ) ; then 
                file_ext=".fastq.gz"
            else
                file_ext=".fastq"
            fi
        else
            if ( file "$fwd" | grep -q compressed ) ; then 
                file_ext=".fastq.gz"
            else
                file_ext=".fastq"
            fi
        fi #symlink check
        if [ ! -f "$output_dir"/pre_QC/fastp.json ]
        then
            timeout -s 1 5m \
            fastp -i $fwd \
                -I $rev \
                -o "$output_dir"/$(basename $fwd $file_ext).filtered.fastq.gz \
                --detect_adapter_for_pe \
                -O "$output_dir"/$(basename $rev $file_ext).filtered.fastq.gz \
                -h "$output_dir"/pre_QC/fastp.html -j "$output_dir"/pre_QC/fastp.json 2>&2
            tko=$(echo $?)
            if [[ "$tko" -eq 124 ]]
            then
                timeout -s 1 1h \
                repair.sh -Xmx14g \
                in1="$fwd" \
                in2="$rev" \
                out1="$output_dir"/$(basename "$fwd" $file_ext).repaired.fastq.gz \
                out2="$output_dir"/$(basename "$rev" $file_ext).repaired.fastq.gz \
                outs="$output_dir"/"$cat_num"_"$ext_num"_"$sub_id"_singletons.fastq.gz \
                repair 2>&2
                tko=$(echo $?)
                if [[ "$tko" -eq 124 ]]
                then
                    logger "trim filt" "Fail"
                fi
                fwd="$output_dir"/$(basename "$fwd" $file_ext).repaired.fastq.gz
                rev="$output_dir"/$(basename "$rev" $file_ext).repaired.fastq.gz
                timeout -s 1 30m \
                fastp -i $fwd \
                    -I $rev \
                    -o "$output_dir"/$(basename $fwd $file_ext).filtered.fastq.gz \
                    --detect_adapter_for_pe \
                    -O "$output_dir"/$(basename $rev $file_ext).filtered.fastq.gz \
                    -h "$output_dir"/pre_QC/fastp.html -j "$output_dir"/pre_QC/fastp.json 2>&2
                tko=$(echo $?)
                if [[ "$tko" -eq 124 ]]
                then
                    logger "FINAL trim filt" "Fail"
                fi
            fi #end timeout repeat of fastp post-repair
        fi #end fastp

        if [ -f "$output_dir"/$(basename $rev $file_ext).filtered.fastq.gz ]
        then
            logger "Read trimming and filtering with fastp " "Success"| tee -a "$log_path" >&2
        else
            logger "fastp output not found. " "Fail"| tee -a "$log_path" >&2
            continue
        fi #if short filtered.fastq.gz exists
    fi #if json
}

run_multiqc(){
    output_dir=$1
    fwd=$2
    rev=$3
    THREADS=$4

    if [ -d "$output_dir"/pre_QC/multiqc_plots ]
    then
        logger "FastQC and MultiQC" "Done" | tee -a "$log_path" >&2
    else 
        logger " Pre-QC analysis compilation with FastqQC and MultiQC." "Start" | tee -a "$log_path" >&2
        fastqc "$fwd" "$rev" -t "$THREADS" -o "$output_dir"/pre_QC 2>&2
        multiqc -m fastqc -p "$output_dir"/pre_QC -o "$output_dir"/pre_QC 2>&2
        logger "Pre-QC analysis compilation with FastQC, and MultiQC " "Success" | tee -a "$log_path" >&2    
    fi
}

consensus(){
    outdir=$1
    output_name=$2
    FWD=$3
    REV=$4
    THREADS=$5
    REF=$6
    MIN_FREQ=$7
    MIN_COV=$8

    ref_id=$(basename $REF .fasta)
    bam_path=$outdir/"$output_name"_"reads_to_reference"_"$ref_id"_mapping.bam
    bam_path_final=$outdir/"$output_name"_"reads_to_reference"_"$ref_id"_mapping_indelqual_alnqual.bam
    vcf_path=$outdir/"$output_name"_"reads_to_reference"_"$ref_id"_lofreq.vcf
    consensus_path=$outdir/"$output_name"_"reads_to_reference"_"$ref_id"_consensus.fasta

    #### Copy REF TO WORKING DIR ####
    if [ ! -f "$outdir"/"$ref_id".fasta ]
    then
        cp $REF "$outdir"/"$ref_id".fasta
        REF="$outdir"/"$ref_id".fasta
    fi
    #### MAP READS ####
    if [ -f "$bam_path" ]
    then
        echo "$(date) mapping.bam already exists" | tee -a "$log_path" >&2
    else
        map_reads $FWD $REV $REF $outdir $THREADS $bam_path
    fi
    #### CALL VARIANTS  ####
    if [ -f "$vcf_path" ]
    then
        echo "$(date) lofreq.vcf already exists" | tee -a "$log_path" >&2
    else
        call_variants $REF $bam_path $vcf_path $THREADS $MIN_FREQ $MIN_COV
    fi
    #### GENERATE CONSENSUS SEQUENCE AND PERFORM POST QC ####
    if [ -f "$consensus_path" ]
    then
        echo "$(date) consensus.fasta already exists" | tee -a "$log_path" >&2
    else
        ## call_consensus bam_path vcf_path ref_path output_dir_path consensus_name threads rename_headers
        call_consensus $bam_path_final $vcf_path $REF $outdir $consensus_path $THREADS $MIN_COV
    fi

    #### CLEAN UP DIRECTORY ####
    if [ -f "$outdir"/pre-bqsr.bam ]
    then
        rm "$outdir"/pre-bqsr*
        rm "$outdir"/recalibration_quality.pdf
        rm "$outdir"/*.tbl
        rm "$outdir"/*.bai
        rm "$outdir"/*.dict
        rm "$outdir"/*.fasta.*
    fi

} #end consensus function
